<!DOCTYPE html><html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
  <title>高校生のための計算トレ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2c3e50">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Helvetica Neue', sans-serif;
      background: #f0f2f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      color: #2c3e50;
    }h1 {
  font-size: 1.2em;
  margin: 0.3em;
}

#mode-select {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0.8em;
  margin: 0.5em;
  font-size: 1em;
}
#mode-select label {
  display: flex;
  align-items: center;
  gap: 0.2em;
}

#question {
  font-size: 1.8em;
  margin: 0.3em;
  display: flex;
  align-items: center;
  justify-content: center;
  padding-left: 2em;
  margin-bottom: 0em;
}
#problemText{

}


#answerInput {
  font-size: 1em;
  font-weight: bold;
  margin-left: 0.5em;
  min-width: 4em;
/*  padding: 0.4em 0em;     /* ← 上下0.4em, 左右0.6em に増やす */
/*  background: white;
  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: inset 0 0 2px #eee;
  display: inline-block;
  line-height: 1.2;*/
}

#result {
  font-size: 1.0em;
  height: 1.1em;
  margin: 0.1em;
}

.keypad-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.4em;
  width: 100%;
  max-width: 320px;
  margin-top: 0.8em;  /* ← これを追加！ */
}

.keypad-grid button {
  padding: 0.6em 0.8em; /* 縦方向のパディングを減らす */
  font-size: 1.2em;     /* 文字サイズも少し控えめに */
  border: none;
  border-radius: 8px;
  color: white;
}

.keypad-grid button:not(.btn-ok):not(.btn-delete) {
  background: #3498db;
}

.btn-delete {
  background: #e74c3c !important;
}

.btn-delete:hover {
  background: #c0392b !important;
}

.btn-ok {
  background: #2ecc71 !important;
}

.btn-ok:hover {
  background: #27ae60 !important;
}

.keypad-grid button:hover {
  filter: brightness(0.95);
}

#restartBtn {
  margin-top: 1em;
  padding: 0.6em 1.2em;
  font-size: 1.2em;
  background: #2ecc71;
  border: none;
  border-radius: 6px;
  color: white;
}

#memo-container {
  margin: 0.2em 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  
  border-top: 1px solid #ccc;  /* ← 区切り線を追加 */
  padding-top: 0.5em;          /* 線と下の余白 */
  margin-top: 0.8em;           /* 線とキーパッドの間隔 */
}
#memo-buttons {
  display: flex;
  gap: 1em;
  margin-top: 0.5em;
}
#clearBtn {
  margin-top: 0.5em;
  padding: 0.3em 1em;
  font-size: 1em;
  border: none;
  border-radius: 6px;
  background: #e67e22;
  color: white;
  }
#hissanBtn {
  margin-top: 0.5em;
  padding: 0.3em 1em;
  font-size: 1em;
  border: none;
  border-radius: 6px;
  background: #2ecc71;
  color: white;
}
#memo-canvas {
  border: 1px solid #ccc;
  background: white;
  touch-action: none;
  width: 90vw;
  height: 20vh; /* ← ここを使うことで画面の縦の20%を使う */
  max-height: 200px;
}



  </style>
</head>
<body><h1>高校生のための計算トレ</h1>
<div id="mode-select">
  <label><input type="radio" name="mode" value="all" checked> all</label>
  <label><input type="radio" name="mode" value="+"> ＋</label>
  <label><input type="radio" name="mode" value="-"> −</label>
  <label><input type="radio" name="mode" value="×"> ×</label>
  <label><input type="radio" name="mode" value="÷"> ÷</label>
</div>
<div id="result"> </div>
<div id="question">
  <span id="problemText">読み込み中...</span>
  <span id="answerInput"> </span>
</div>
  <div id="memo-container">
  <canvas id="memo-canvas" width="300" height="150"></canvas>
  <div id="memo-buttons">
    <button id="clearBtn">メモを消す</button> 
    <button id="hissanBtn">筆算on</button>
  </div>
</div>
<div class="keypad-grid" id="keypad"></div>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js').then(registration => {
        registration.onupdatefound = () => {
          const newWorker = registration.installing;
          newWorker.onstatechange = () => {
            if (newWorker.state === 'installed') {
              if (navigator.serviceWorker.controller) {
                if (confirm('新しいバージョンがあります。更新しますか？')) {
                  location.reload();
                }
              }
            }
          };
        };
      });
    });
  }

  document.getElementById("hissanBtn").addEventListener("click", () => {
    document.body.classList.toggle("hissan-mode");
    const isOn = document.body.classList.contains("hissan-mode");
    document.getElementById("hissanBtn").textContent = isOn ? "筆算off" : "筆算on";
    showProblem();
  });

  function hissanOff() {
    if (document.body.classList.contains("hissan-mode")) {
      document.body.classList.remove("hissan-mode");
    }
    document.getElementById("hissanBtn").textContent = "筆算on";
  }

  function rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function randList(...numbers) {
    const index = Math.floor(Math.random() * numbers.length);
    return numbers[index];
  }

  function getDigitLength(n) {
    const intPart = Math.floor(Math.abs(n));
    return intPart.toString().length;
  }

  function getDecimalLength(n) {
    const fixed = n.toFixed(2);
    const parts = fixed.split(".");
    return parts[1] ? parts[1].replace(/0+$/, "").length : 0;
  }

  function getSelectedOperators() {
    const selected = document.querySelector('input[name="mode"]:checked').value;
    return selected === "all" ? ["+", "-", "×", "÷"] : [selected];
  }

  function generateProblems() {
    problems = [];
    const selectedOperators = getSelectedOperators();

    for (let i = 0; i < 10; i++) {
      const op = selectedOperators[Math.floor(Math.random() * selectedOperators.length)];
      let a, b, ans;

      if (op === "+") {
        do {
          a = parseFloat((rand(11, 999) / randList(1, 1, 10, 100)).toFixed(2));
          b = parseFloat((rand(11, 999) / randList(1, 1, 10, 100)).toFixed(2));
        } while (
          Math.abs(getDecimalLength(a) - getDecimalLength(b)) >= 2 ||
          Math.abs(getDigitLength(a) - getDigitLength(b)) >= 2
        );
        ans = parseFloat((a + b).toFixed(2));
      } else if (op === "-") {
        do {
          a = parseFloat((rand(11, 999) / randList(1, 1, 10, 100)).toFixed(2));
          b = parseFloat((rand(11, 999) / randList(1, 1, 10, 100)).toFixed(2));
        } while (
          Math.abs(getDecimalLength(a) - getDecimalLength(b)) >= 2 ||
          Math.abs(getDigitLength(a) - getDigitLength(b)) >= 2
        );
        ans = parseFloat((a - b).toFixed(2));
      } else if (op === "×") {
        a = rand(10, 99);
        b = rand(2, 9);
        ans = a * b;
      } else {
        b = rand(10, 99);
        ans = rand(2, 9);
        a = b * ans;
      }

      problems.push({ a, b, op, ans });
    }

    current = score = 0;
    waitForUser = false;
    showProblem();
  }

  function showProblem() {
    if (current >= problems.length) return showResult();

    const p = problems[current];
    const ishissan = document.body.classList.contains("hissan-mode");

    if (ishissan) {
      const format = n => n.toFixed(2).replace(/\.?0+$/, '');
      const aStr = format(p.a);
      const bStr = format(p.b);
      const [ai, apRaw = ""] = aStr.split(".");
      const [bi, bpRaw = ""] = bStr.split(".");
      const ap = apRaw ? '.' + apRaw : '  ';
      const bp = bpRaw ? '.' + bpRaw : '  ';
      const leftMax = Math.max(ai.length, bi.length);
      const rightMax = Math.max(ap.length, bp.length);
      const aiPad = ai.padStart(leftMax, " ");
      const biPad = bi.padStart(leftMax, " ");
      const apPad = ap.padEnd(rightMax, " ");
      const bpPad = bp.padEnd(rightMax, " ");

      let aLine = aiPad + apPad;
      let bLine = p.op + biPad + bpPad;
      // 引き算で答えが負なら aとbを入れ替える
      if ((p.op === "-") && (p.a - p.b < 0)) {
        [aLine, bLine] = [bLine, aLine];
      }
      document.getElementById("problemText").innerHTML = `
        <pre style="text-align:right; font-family: Menlo, Consolas, monospace; line-height:1.1; margin:0;">
${aLine}
${bLine}</pre>`;
    } else {
      document.getElementById("problemText").textContent = `${p.a} ${p.op} ${p.b} =`;
    }

    userInput = "";
    updateInput();
    document.getElementById("result").textContent = "";
  }

  function updateInput() {
    document.getElementById("answerInput").textContent = userInput || " ";
  }

  function setupKeypad() {
    const keys = [
      "7", "8", "9", "Delete",
      "4", "5", "6", "",
      "1", "2", "3", "ENTER",
      "-", "0", ".", ""
    ];

    const keypad = document.getElementById("keypad");
    keypad.innerHTML = "";

    keys.forEach(k => {
      const btn = document.createElement("button");
      if (k === "") {
        btn.style.visibility = "hidden";
      } else {
        btn.textContent = k;
        if (k === "Delete") btn.classList.add("btn-delete");
        else if (k === "ENTER") btn.classList.add("btn-ok");
        btn.onclick = () => handleKey(k);
      }
      keypad.appendChild(btn);
    });
  }

  function handleKey(key) {
    if (waitForUser) return;

    if (key === "Delete") {
      userInput = userInput.slice(0, -1);
    } else if (key === "ENTER") {
      if (userInput.trim() === "" || userInput === "-") return;
      checkAnswer();
    } else if (key === "-") {
      if (userInput === "") userInput = "-";
    } else {
      userInput += key;
    }

    updateInput();
  }

  function checkAnswer() {
    const p = problems[current];
    const userNum = parseFloat(userInput);
    const correct = Math.abs(userNum - p.ans) < 0.001;
    const resultBox = document.getElementById("result");

    if (correct) {
      score++;
      resultBox.textContent = "正解👍";
      setTimeout(() => advanceNext(), 800);
    } else {
      resultBox.textContent = `不正解😢… 正解は ${p.ans}`;
      setTimeout(() => {
        waitForUser = true;
      }, 500);
    }
  }

  function advanceNext() {
    waitForUser = false;
    current++;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
//    hissanOff();
    showProblem();
  }

  document.addEventListener("click", (e) => {
    if (waitForUser) {
      advanceNext();
      e.stopPropagation();
    }
  });

  function showResult() {
    const msg = (score === 10) ? "満点！天才か！？"
              : (score >= 8) ? "やるやん！あと少し！"
              : (score >= 5) ? "いいペース！"
              : (score >= 3) ? "まだ伸びしろあるね！"
              : "次が本番や…！";

    const emoji = (score === 10) ? "💯✨👏"
                : (score >= 8) ? "👍🌟"
                : (score >= 5) ? "😊✌️"
                : (score >= 3) ? "🙌📈"
                : "😅🔥";

    document.body.innerHTML = `
      <style>
        body {
          background: #fffdf5;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          animation: fadeIn 1s ease-in-out;
        }
        h1 {
          font-size: 2em;
          animation: popIn 0.6s ease-out;
          margin-bottom: 0.3em;
        }
        .score-msg, .emoji {
          font-size: 1.6em;
          margin: 0.4em 0;
          animation: sway 2s ease-in-out infinite alternate;
        }
        .emoji { font-size: 2.2em; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes sway { 0% { transform: rotate(-3deg); } 100% { transform: rotate(3deg); } }
        #restartBtn {
          margin-top: 1.2em;
          padding: 0.7em 1.4em;
          font-size: 1.2em;
          background: #f39c12;
          color: white;
          border: none;
          border-radius: 10px;
          animation: popIn 1s ease-out;
        }
        #restartBtn:hover { background: #e67e22; }
      </style>
      <h1>お疲れさま！</h1>
      <div class="emoji">${emoji}</div>
      <div class="score-msg">スコア：${score} / 10</div>
      <div class="score-msg">${msg}</div>
      <button id="restartBtn" onclick="location.reload()">もう1回やる！</button>
    `;
  }

  generateProblems();
  setupKeypad();

  const canvas = document.getElementById("memo-canvas");
  const ctx = canvas.getContext("2d");
  let drawing = false;

  function startDraw(e) {
    drawing = true;
    ctx.beginPath();
    ctx.moveTo(getX(e), getY(e));
  }

  function draw(e) {
    if (!drawing) return;
    ctx.lineTo(getX(e), getY(e));
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.stroke();
  }

  function endDraw() {
    drawing = false;
  }

  function getX(e) {
    return e.touches ? e.touches[0].clientX - canvas.getBoundingClientRect().left : e.offsetX;
  }

  function getY(e) {
    return e.touches ? e.touches[0].clientY - canvas.getBoundingClientRect().top : e.offsetY;
  }

  canvas.addEventListener("mousedown", startDraw);
  canvas.addEventListener("mousemove", draw);
  canvas.addEventListener("mouseup", endDraw);
  canvas.addEventListener("mouseleave", endDraw);

  canvas.addEventListener("touchstart", startDraw);
  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    draw(e);
  }, { passive: false });
  canvas.addEventListener("touchend", endDraw);
  canvas.addEventListener("touchcancel", endDraw);

  document.getElementById("clearBtn").addEventListener("click", () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });

  document.querySelectorAll('input[name="mode"]').forEach(input => {
    input.addEventListener("change", () => {
      generateProblems();
    });
  });
</script>
</body>
</html>
